# 1-7 基础运算与运算符

## 算术运算

算术运算可用于数字类型之间，采用用数学上相同的中缀写法与优先级。

基本二元算术运算符有：加`+`，减`-`，乘`*`，除`/`，模`%`。

运算符的行为基本与数学上相同，但会根据参数类型发生变化：
- 若左右两边类型不同，则进行隐式转换得到相同的类型再运算：
  - `ulong`与有符号整数不能互相直接运算；
  - 短整数与`long`运算时转换为`long`，与`int`运算时转换为`int`；
  - 短无符号整数与`ulong`运算时转换为`ulong`，与`uint`运算时转换为`uint`；
  - 短有符号整数与`uint`运算时转换为`ulong`；
  - 其余情况的整数运算皆转换为`int`；
  - `char`将先被转换为`int`后再按照整数规则转换，即使与自己运算也是如此，例外是可以直接被转换为`ulong`；
  - 整数总是可以被转换为浮点数进行运算；
- 整数除法的结果为整数，取整方向为接近0；
  - 整数、`decimal`除法除以0将会引发运行时错误(`DividedByZeroException`)；
  - `float`、`double`除以0将会得到特殊值：正/负无穷大或者`Nan`；
- 模运算即为算术中的余数，但对于负数和浮点数也可用：
  - 其行为定义为：与被除数同号、相差除数的整数倍中，离0最近的数字。

运算符的两边可以为变量/表达式，也可以为字面值。当至少有一方为字面值时，部分溢出/除0检查会被提前到编译期。当双方都为字面值时，整个运算都会在编译期完成，效果相当于直接写出结果值的字面值。

```csharp
int a = (x + 1) * y;
int b = int.MaxValue + 1; //编译时认为溢出
int c = a / 0; //编译时认为除0
float d = a / 0f; //浮点数除0合法，运行时根据a的符号获得结果
double m = a / 2.0; //常用的算术除2方法
```

### 算术运算的溢出检查

算术运算的溢出控制使用与类型转换相同的`checked`/`unchecked`语法，并受相同的编译器选项控制：

```csharp
uint a = 1, b = 2;
uint c = checked(a - b);
```

当字面值的运算被提前到编译期时，会默认检查溢出，除非被包在`unchecked`块中。

`decimal`上的运算固定检查溢出。

## 逻辑运算

逻辑运算可用于逻辑类型`bool`上。

有2种二元逻辑运算符：与`&&`，或`||`，以及一元逻辑运算符非`!`，分别进行逻辑代数的3种基本运算。与仅对`true&&true`获得`true`，或仅对`false||false`获得`false`，非将`true`和`false`互相反转。

## 位运算

位运算将数字二进制表示中的1和0映射为`true`和`false`，然后逐位进行与相应的逻辑运算，在计算机底层和算法优化的场合经常被使用。位运算可用于32位或以上的整数上。

有3种二元位运算符：位与`&`，位或`|`，位异或`^`，以及一元位运算符位反`~`。`&`、`|`、`~`分别对应3种逻辑运算符，而`^`在两个运算数相应位不一致时置1。

当位运算的两边类型不同时，也会进行转换：
- 32位以下整数和`char`皆可被转换为`int`；
- 同长度有无符号运算时，结果为无符号（即只有`uint`、`ulong`）；
- 32位与64位运算时，结果类型与64位者相同。

> 有符号数在类型转换时的补0/补1在位运算中容易引发值不一致性，尽量先手动转换再做位运算。

## 移位运算

移位运算符`<<`、`>>`将整数的二进制表示向左或右移动一定位数，相当于快速乘/除2的一个幂，可用于32位或以上的整数上。使用格式为`待移位数>>移位位数`，其中移位位数必须使用`int`类型。

左移时，移出左端的位将被丢弃，右端补0，相当于CPU中的算术/逻辑左移。

右移时，移出右端的位将被丢弃，若源为无符号则左端补0，相当于CPU中的逻辑右移；若源为有符号则左端补上原先的最左位，相当于CPU中的算术右移。

> CPU中的循环移位概念（即将移出一端的位填回另一端）在.NET中没有提供直接支持，但可以通过简单的拆位-交错移动-复合操作来实现。

## 关系运算

关系运算符测试两个值之间的相等或大小关系，并返回一个`bool`表示结果。可用的运算符有：相等`==`、不等`!=`、大于`>`、小于`<`、大于等于`>=`、小于等于`<=`。除了`bool`和`string`仅能判断相等或不等以外，其余数字类型皆可使用所有关系运算。

左右两个数字类型不同时，若有一方能隐式转换为另一方，则会转换并比较。

> 浮点数在计算中如有误差累计，可能会出现两个值很相近但并不相等的情况，这时一般以差小于阈值来判定。

## 字符串拼接运算

字符串拼接也使用`+`来表示，将两个`string`的内容拼接在一起获得一个新的`string`。

也可以一端为`string`而另一端不是，此时另一端将被执行`ToString`。

> 在`string`与非`string`间混合使用`+`时，注意被解读为何种运算。例如，`"A" + 1 + 2`由于运算从左向右结合，将得到`"A12"`，而不是`"A3"`。

## 赋值运算符与自增自减运算符

在二元算术、位、移位运算符后加上`=`便可成为赋值运算符，兼有赋值和运算的行为。例如，`a += b`相当于`a = a + b`。显然，左侧需要为一个可赋值的实体（如变量）。由赋值运算符构成的表达式仍然可以作为一个值继续被赋值或运算，如`c = a += b`。

一元运算符自增`++`、自减`--`，作用为将变量加1或减1后赋值。其有在变量前方和后方两种用法，区别是将「附有自增/自减运算符的变量」作为值继续参与运算时，是否将该`++`/`--`计入。例如：

```csharp
int a = 1;
int b = a++; // a=2, b=1, ++后置代表该语句结束时才对a自增
int c = 1;
int d = ++c; // c=2, d=2, ++前置代表该语句开始前就对a自增
```

> C语系的自增、自减、赋值运算符一直饱受争议。批评的主要原因是：改变变量的表达式仍然可以作为值继续参与运算，这样直接允许了一个变量在一整条表达式中的值不一致性，同时`++`、`--`本身也会引起运算符解析的问题，从而允许了`a += a++`、`a +++ b`这样的式子，不同的C语言编译器甚至对其实现都会有差别。

> 为避免危害，正确的使用方式应为：如果对一个变量使用了自增/自减/赋值运算符，则在同一条语句（分号间隔）内，禁止再次使用该变量。

## 运算符优先级

运算符优先级按照约定俗成的规定：
- 一元运算>二元运算
- 算术>移位>关系>位>逻辑>赋值
- 乘除>加减，与>异或>或

> 不要背诵运算符优先级表，除了浅显的算术约定以外，不要吝啬括号。