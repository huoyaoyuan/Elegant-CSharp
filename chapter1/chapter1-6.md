# 1-6 基础类型之间的转换

## 类型转换操作

类型转换操作是关联在2个类型之间的操作，又被称为**转型算符**。类型转换操作主要发生在数字之间。

### 转型语法

与很多编程语言一样，C#的类型转换分为隐式和显式转换。隐式转换在需求时会直接发生，而显式转换必须在明确写出的情况下才会发生。

与C++相同，如果有自己定义的类型，也能为其定义类型转换。

> 隐式转换的原则是：保证成功、安全、无歧义。在条件不满足或关联不显著时，尽量采用别的方法转换，而非隐式转换。

C#的显式转换采用C风格语法：

```csharp
(目标类型)源类型的值
```

在转换之后，即可赋值给目标类型的变量。例如：

```csharp
long a = 2;
int b = (int)a;
```

### 可以转换的类型

C#在所有的数字类型（即1-4中提到的所有整数、浮点数类型），以及`char`类型之间定义了转型算符，有些为隐式，余下的则为显式。

隐式的转换有：
- 整数之间，目标类型值域覆盖源类型时，即：
  - 位数少的整数到位数多的整数总能隐式转换；
  - 位数相同的带符号数和无符号数之间不能隐式转换；
- `float`到`double`可以隐式转换；
- 整数总能隐式转换为浮点数；
- `char`可以隐式转换为`ushort`或者更大的整数类型，以及浮点数。
  - `char`类型实际上除了不能从`byte`和`sbyte`隐式转换以外，在转换时可以被视为`ushort`。

不在上述列表中的转换皆为显式。

|与C++的区别|
|-|
|C#中逻辑(`bool`)类型与数字之间没有转型操作，需要使用条件判断语句达到目的。C++中这一现象的成因是因为曾经不存在`bool`类型。|

### 转换的精度与溢出规则

C#默认的数字转换方式为允许**溢出**，即当源值落在目标类型的值域外时，会按一定规则取值域内某一值作为转换结果。但当`decimal`类型为源或目标时除外，因为`decimal`类型上没有「允许溢出的操作」。

显然，同为有、无符号整数或二进制浮点数时，从较短类型向较长类型转换，值可以完美无缺地表达。正因如此，这些转换都是隐式转换。

在浮点数转换为整数时，小数部分会被截断丢弃，即更靠近0。

在整数转换为浮点数时，有效数字长度如果超出了浮点数的精度位数，低有效位会被丢弃。实际上根据浮点数的精度位数，只有在32位（或以上）整数转`float`、64位整数转`double`时才会发生这种情况。

> 这是一个会丢失精度的隐式转换。但如果完全排除`long`、`ulong`和`float`的使用，精度可以得到完全保存。

`double`转换为`float`时，有效数字的低位会被丢弃。如果指数过小，则会得到0值；如果指数过大，则会得到正或负无穷大。

`decimal`与`double`和`float`互相转换时，会发生进制换算。转换值过大或过小时，会引发运行时异常，异常类型为溢出(`OverflowException`)。

> 如果表示的值为整数，则进制转换不会丢失精度。

> `decimal`的指数位较短，因此溢出只会发生在从`float`或`double`转换为`decimal`时。

> 由于10的因数包含2，因此2进制小数转换为10进制小数时一定为有限小数，但反之则不一定。无限小数意味着必定被截断损失。

> 由于`decimal`的有效数字为足足96位，所以其可以完全精确表示`long`范围内的数字。

较长整数转换为较短整数时，会直接将高位值截断，在数学上相当于一个求余操作。

同长度有、无符号整数互相转换时，按照二进制数的补码规则。即：有符号类型的`-x`与无符号类型的`类型最大值+1-x`互相转换。

较短有符号整数转换为较长无符号整数时，会先转换为目标长度的有符号整数，再将补码映射到无符号整数。

> 这是一个会引发值不一致性的隐式转换，需要谨慎使用。

`float`或`double`转换为整数时，如果溢出，会得到0值。但`int`和`long`这两个类型的行为除外，其会得到值域最负端的数字。

> 这一情况下的行为不符合规则，也没有规律，因此不要依赖这一行为。

> `decimal`转换为整数时溢出，则按照`decimal`类型的行为，会引发运行时异常。

### 检查溢出的转换

C#编译器的一个选项为「检查运算上溢/下溢」，可以在Visual Studio或者命令行中调整。默认行为为不检查溢出。

如果将表达式或语句包括在`checked`块中，则其中的数值转换（以及算术运算）将会检查溢出。如果发生溢出，则会引发运行时异常`OverflowException`。例如：

```csharp
int i = checked((int)l);
checked
{
    int j = l;
}
```

相应地，使用`uncheck`将强制不检查溢出。（但`decimal`类型参与时仍然会检查溢出）

```csharp
checked
{
    // something
    int i = unchecked((int)l);
}
```

> 技术上，IL中有2套算术、数值转换指令，是否检查溢出实际上对应着不同指令，编译器会根据checked/unchecked上下文选择相应的指令。但`decimal`类型并不是真正IL级别的基元类型，其更相当于一个在C#中存在特殊对待的自定义类型。整个.NET没有提供在自定义类型上指定checked/unchecked的方法，因此`decimal`只能将行为实现为一直checked。

## 转换函数

转换函数为类型的成员函数（又称方法），其返回包含相同值的另一类型值，因此在语义上用作转换。

> 在IL看来，转型算符实际上也是特定名称的方法，但在其属性中有一个SpecialName标记，指示编译器可以按照方法之外的特定用途来使用。

### ToString

.NET类型系统的基干保证，任何类型上都有可用的`ToString`。使用方法为：`值.ToString()`，将会得到一个`string`类型的值。提供的值既可以是某一类型的变量，也可以是一个字面值，如：

```csharp
int a = 1;
string s1 = a.ToString();
var s2 = 2.ToString();
```

> 由于「小数点后必须有十进制数字」和「标识符不得以数字开头」这2条规则，小数点和调用`ToString`（以及其它任何成员方法）的点号永远不会混淆，只需判断开头第一个字符即可。

`Console.WriteLine`（以及很多显示输出型方法）都是在内部先调用`ToString`，再将所得到的`string`进行显示或输出。

基础类型的`ToString`还允许控制字符串的格式，具体在基本输入输出章节描述。允许`ToString`控制格式的类型并不多，主要为.NET框架中的基干性类型。

### Parse

作为`ToString`的逆运算，数字皆提供了分析字符串获得值的方法`Parse`。使用方法为：`类型名.Parse(字符串)`。例如：

```csharp
int a = int.Parse("1");
var f = float.Parse("0.3");
```

在一些其它类型上，也可见到定义的`Parse`方法。基础类型的`Parse`也允许指定能够解读的格式特征。若格式有错误或无法解读，则会引发一个运行时异常（类型为`FormatException`）。

### TryParse

运行时异常需要专门的语法进行处理，且处理耗时远大于程序常规运行。且在很多场合下，输入到`Parse`的字符串来源为用户输入，并不能保证其符合格式要求。为了在格式错误时不引发运行时异常，而采用其它方式报告错误，引入了`TryParse`方法。其使用方法为：`类型名.TryParse(字符串, out 接收变量名)`。

整个`TryParse`调用的值为`bool`，代表着转换是否成功。由于直接使用` = 类型名.TryParse`只能将该`bool`赋值出去，需要额外的语法来让另一个变量接受分析字符串的值。`out`修饰符即为此含义，指定写在该位置的变量将从方法中接收返回值。

```csharp
int i;
bool success = int.TryParse("100", out i);
```

为了简化这一调用语句，C# 7.0引入了在`out`处立即定义变量并接收值的方式。以下两种用法皆与上两条语句等价：

```csharp
bool success = int.TryParse("100", out int i);
bool success = int.TryParse("100", out var i);
```

> `TryXXX`在.NET中是一个很常见的设计，用来应对操作失败率较高的场合。
