# 1-6 基础类型之间的转换

## 类型转换操作

类型转换操作是关联在2个类型之间的操作，又被称为**转型算符**。类型转换操作主要发生在数字之间。

### 转型语法

与很多编程语言一样，C#的类型转换分为隐式和显式转换。隐式转换在需求时会直接发生，而显式转换必须在明确写出的情况下才会发生。

与C++相同，如果有自己定义的类型，也能为其定义类型转换。

> 隐式转换的原则是：保证成功、安全、无歧义。在条件不满足或关联不显著时，尽量采用别的方法转换，而非隐式转换。

C#的显式转换采用C风格语法：

```csharp
(目标类型)源类型的值
```

在转换之后，即可赋值给目标类型的变量。例如：

```csharp
long a = 2;
int b = (int)a;
```

### 可以转换的类型

C#在所有的数字类型（即1-4中提到的所有整数、浮点数类型），以及`char`类型之间定义了转型算符，有些为隐式，余下的则为显式。

隐式的转换有：
- 整数之间，目标类型值域覆盖源类型时，即：
  - 位数少的整数到位数多的整数总能隐式转换；
  - 位数相同的带符号数和无符号数之间不能隐式转换；
- `float`到`double`可以隐式转换；
- 整数总能隐式转换为浮点数；
- `char`可以隐式转换为`ushort`或者更大的整数类型，以及浮点数。
  - `char`类型实际上除了不能从`byte`和`sbyte`隐式转换以外，在转换时可以被视为`ushort`。

不在上述列表中的转换皆为显式。

|与C++的区别|
|-|
|C#中逻辑(`bool`)类型与数字之间没有转型操作，需要使用条件判断语句达到目的。C++中这一现象的成因是因为曾经不存在`bool`类型。|

### 转换的精度与溢出规则

C#默认的数字转换方式为允许**溢出**，即当源值落在目标类型的值域外时，会按一定规则取值域内某一值作为转换结果。但当`decimal`类型为源或目标时除外，因为`decimal`类型上没有「允许溢出的操作」。

显然，同为有、无符号整数或二进制浮点数时，从较短类型向较长类型转换，值可以完美无缺地表达。正因如此，这些转换都是隐式转换。

在浮点数转换为整数时，小数部分会被截断丢弃，即更靠近0。

在整数转换为浮点数时，有效数字长度如果超出了浮点数的精度位数，低有效位会被丢弃。实际上根据浮点数的精度位数，只有在32位（或以上）整数转`float`、64位整数转`double`时才会发生这种情况。

> 这是一个会丢失精度的隐式转换。但如果完全排除`long`、`ulong`和`float`的使用，精度可以得到完全保存。

`double`转换为`float`时，有效数字的低位会被丢弃。如果指数过小，则会得到0值；如果指数过大，则会得到正或负无穷大。

`decimal`与`double`和`float`互相转换时，会发生进制换算。转换值过大或过小时，会引发运行时异常，异常类型为溢出(`OverflowException`)。

> 如果表示的值为整数，则进制转换不会丢失精度。

> `decimal`的指数位较短，因此溢出只会发生在从`float`或`double`转换为`decimal`时。

> 由于10的因数包含2，因此2进制小数转换为10进制小数时一定为有限小数，但反之则不一定。无限小数意味着必定被截断损失。

> 由于`decimal`的有效数字为足足96位，所以其可以完全精确表示`long`范围内的数字。

较长整数转换为较短整数时，会直接将高位值截断，在数学上相当于一个求余操作。

同长度有、无符号整数互相转换时，按照二进制数的补码规则。即：有符号类型的`-x`与无符号类型的`类型最大值+1-x`互相转换。

较短有符号整数转换为较长无符号整数时，会先转换为目标长度的有符号整数，再将补码映射到无符号整数。

> 这是一个会引发值不一致性的隐式转换，需要谨慎使用。

`float`或`double`转换为整数时，如果溢出，会得到0值。但`int`和`long`这两个类型的行为除外，其会得到值域最负端的数字。

> 这一情况下的行为不符合规则，也没有规律，因此不要依赖这一行为。

> `decimal`转换为整数时溢出，则按照`decimal`类型的行为，会引发运行时异常。

### 检查溢出的转换

C#编译器的一个选项为「检查运算上溢/下溢」，可以在Visual Studio或者命令行中调整。默认行为为不检查溢出。

如果将表达式或语句包括在`checked`块中，则其中的数值转换（以及算术运算）将会检查溢出。如果发生溢出，则会引发运行时异常`OverflowException`。例如：

```csharp
int i = checked((int)l);
checked
{
    int j = l;
}
```

相应地，使用`uncheck`将强制不检查溢出。（但`decimal`类型参与时仍然会检查溢出）

```csharp
checked
{
    // something
    int i = unchecked((int)l);
}
```

> 技术上，IL中有2套算术、数值转换指令，是否检查溢出实际上对应着不同指令，编译器会根据checked/unchecked上下文选择相应的指令。但`decimal`类型并不是真正IL级别的基元类型，其更相当于一个在C#中存在特殊对待的自定义类型。整个.NET没有提供在自定义类型上指定checked/unchecked的方法，因此`decimal`只能将行为实现为一直checked。
